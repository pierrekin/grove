//! Implementation of the `#[derive(Service)]` macro.
//!
//! This module generates the handle struct and getters.
//! The spawn function is generated by #[grove::handlers].

use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{Data, DeriveInput, Error, Field, Fields, Ident, Result, Type};

/// Main entry point for the Service derive macro.
pub fn expand(input: DeriveInput) -> Result<TokenStream> {
    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => {
                return Err(Error::new_spanned(
                    &input,
                    "Service can only be derived for structs with named fields",
                ))
            }
        },
        _ => {
            return Err(Error::new_spanned(
                &input,
                "Service can only be derived for structs",
            ))
        }
    };

    let struct_name = &input.ident;
    let handle_name = format_ident!("{}Handle", struct_name);
    let command_type = format_ident!("{}Command", struct_name);

    // Parse struct-level attributes for emits = [...]
    let emitted_events = parse_emits(&input)?;

    // Parse field attributes
    let getters: Vec<GetterField> = fields
        .iter()
        .filter_map(|f| GetterField::from_field(f).transpose())
        .collect::<Result<_>>()?;

    // Find emitter field name if present
    let emitter_field = find_emitter_field(fields)?;

    // Generate code
    let handle_struct = generate_handle_struct(struct_name, &handle_name, &command_type, &emitted_events);
    let getter_impls = generate_getters(&handle_name, &getters);
    let subscription_methods = generate_subscription_methods(&handle_name, &emitted_events, &emitter_field);
    let event_channel_helper = generate_event_channel_helper(struct_name, &emitted_events, &emitter_field);

    Ok(quote! {
        #handle_struct
        #getter_impls
        #subscription_methods
        #event_channel_helper
    })
}

/// Parse #[grove(emits = [Event1, Event2])] from struct attributes.
fn parse_emits(input: &DeriveInput) -> Result<Vec<Ident>> {
    let mut events = Vec::new();

    for attr in &input.attrs {
        if !attr.path().is_ident("grove") {
            continue;
        }

        attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("emits") {
                meta.input.parse::<syn::Token![=]>()?;

                // Parse [Event1, Event2, ...]
                let content;
                syn::bracketed!(content in meta.input);

                while !content.is_empty() {
                    let event: Ident = content.parse()?;
                    events.push(event);

                    if content.is_empty() {
                        break;
                    }
                    content.parse::<syn::Token![,]>()?;
                }
                Ok(())
            } else {
                // Ignore other attributes (they might be for fields)
                Ok(())
            }
        })?;
    }

    Ok(events)
}

// ============================================================================
// Field Parsing
// ============================================================================

struct GetterField {
    name: Ident,
    ty: Type,
}

impl GetterField {
    fn from_field(field: &Field) -> Result<Option<Self>> {
        let name = field
            .ident
            .clone()
            .expect("we already verified these are named fields");

        for attr in &field.attrs {
            if !attr.path().is_ident("grove") {
                continue;
            }

            let mut is_getter = false;
            let mut is_skip = false;
            let mut is_emitter = false;

            attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("get") {
                    is_getter = true;
                } else if meta.path.is_ident("skip") {
                    is_skip = true;
                } else if meta.path.is_ident("emitter") {
                    is_emitter = true;
                }
                Ok(())
            })?;

            if is_getter {
                return Ok(Some(Self {
                    name,
                    ty: field.ty.clone(),
                }));
            }

            if is_skip || is_emitter {
                return Ok(None);
            }
        }

        Ok(None)
    }
}

// ============================================================================
// Code Generation
// ============================================================================

fn generate_handle_struct(
    struct_name: &Ident,
    handle_name: &Ident,
    command_type: &Ident,
    _emitted_events: &[Ident],
) -> TokenStream {
    // Handle struct no longer includes event senders - subscriptions go through
    // the Emitter in the state
    quote! {
        /// Handle for interacting with the service.
        #[derive(Clone)]
        pub struct #handle_name {
            state: grove::runtime::Arc<grove::runtime::RwLock<#struct_name>>,
            cmd_tx: grove::runtime::mpsc::Sender<#command_type>,
        }
    }
}

fn generate_getters(handle_name: &Ident, getters: &[GetterField]) -> TokenStream {
    let getter_methods: Vec<TokenStream> = getters
        .iter()
        .map(|getter| {
            let field_name = &getter.name;
            let field_type = &getter.ty;

            quote! {
                pub fn #field_name(&self) -> #field_type {
                    self.state.read().unwrap().#field_name.clone()
                }
            }
        })
        .collect();

    if getter_methods.is_empty() {
        return quote! {};
    }

    quote! {
        impl #handle_name {
            #(#getter_methods)*
        }
    }
}

/// Generate subscription methods for each emitted event.
fn generate_subscription_methods(
    handle_name: &Ident,
    emitted_events: &[Ident],
    emitter_field: &Option<Ident>,
) -> TokenStream {
    // Only generate if there's an emitter field
    let emitter_field = match emitter_field {
        Some(f) if !emitted_events.is_empty() => f,
        _ => return quote! {},
    };

    let methods: Vec<TokenStream> = emitted_events
        .iter()
        .map(|event| {
            let method_name = format_ident!("on_{}", to_snake_case(&event.to_string()));

            quote! {
                /// Subscribe to this event type.
                pub fn #method_name(&self) -> grove::runtime::broadcast::Receiver<#event> {
                    self.state.read().unwrap().#emitter_field.subscribe::<#event>()
                }
            }
        })
        .collect();

    quote! {
        impl #handle_name {
            #(#methods)*
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

/// Find the field marked with #[grove(emitter)]
fn find_emitter_field(
    fields: &syn::punctuated::Punctuated<Field, syn::token::Comma>,
) -> Result<Option<Ident>> {
    for field in fields {
        for attr in &field.attrs {
            if !attr.path().is_ident("grove") {
                continue;
            }

            let mut is_emitter = false;
            attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("emitter") {
                    is_emitter = true;
                }
                Ok(())
            })?;

            if is_emitter {
                return Ok(field.ident.clone());
            }
        }
    }
    Ok(None)
}

/// Generate helper method to wire up event channels.
/// This creates the Emitter and returns the broadcast senders needed for the handle.
fn generate_event_channel_helper(
    struct_name: &Ident,
    emitted_events: &[Ident],
    emitter_field: &Option<Ident>,
) -> TokenStream {
    // Only generate if there's an emitter field and events to emit
    let emitter_field = match emitter_field {
        Some(f) if !emitted_events.is_empty() => f,
        _ => return quote! {},
    };

    // Generate sender field names and channel creation
    let sender_fields: Vec<Ident> = emitted_events
        .iter()
        .map(|event| format_ident!("{}_tx", to_snake_case(&event.to_string())))
        .collect();

    let channel_creation: Vec<TokenStream> = emitted_events
        .iter()
        .zip(sender_fields.iter())
        .map(|(event, field)| {
            quote! {
                let #field = builder.add_event::<#event>(256);
            }
        })
        .collect();

    // Generate tuple type and value for senders
    let sender_types: Vec<TokenStream> = emitted_events
        .iter()
        .map(|event| quote! { grove::runtime::broadcast::Sender<#event> })
        .collect();

    let sender_values: Vec<&Ident> = sender_fields.iter().collect();

    quote! {
        impl #struct_name {
            /// Wires up the event channels and returns the broadcast senders.
            /// Call this before spawn() to get the senders needed for the handle.
            #[doc(hidden)]
            pub fn wire_events(&mut self) -> (#(#sender_types),*,) {
                let mut builder = grove::event::EmitterBuilder::new();
                #(#channel_creation)*
                self.#emitter_field = builder.build();
                (#(#sender_values),*,)
            }
        }
    }
}
