//! Implementation of the `#[grove::service]` attribute macro.
//!
//! This attribute macro:
//! - Optionally injects an emitter field for services that emit events
//! - Generates the handle struct
//! - Generates getters and subscription methods
//! - Generates emit_<event>() methods

use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{
    parse::Parser, parse2, Data, DeriveInput, Error, Expr, Field, Fields, FieldsNamed, Ident,
    Result, Type,
};

/// Main entry point for the service attribute macro.
pub fn expand(_attr: TokenStream, item: TokenStream) -> Result<TokenStream> {
    let mut input: DeriveInput = parse2(item)?;

    // Parse struct-level attributes
    let attrs = parse_struct_attrs(&input)?;
    let emitted_events = attrs.emitted_events;
    let poll_signature = attrs.poll_types;

    // Get mutable access to fields
    let fields = match &mut input.data {
        Data::Struct(data) => match &mut data.fields {
            Fields::Named(fields) => fields,
            _ => {
                return Err(Error::new_spanned(
                    &input,
                    "grove::service can only be applied to structs with named fields",
                ))
            }
        },
        _ => {
            return Err(Error::new_spanned(
                &input,
                "grove::service can only be applied to structs",
            ))
        }
    };

    let struct_name = &input.ident;
    let handle_name = format_ident!("{}Handle", struct_name);

    // Parse field attributes for getters BEFORE injecting emitter
    let getters: Vec<GetterField> = fields
        .named
        .iter()
        .filter_map(|f| GetterField::from_field(f).transpose())
        .collect::<Result<_>>()?;

    // Parse field attributes for defaults BEFORE injecting emitter
    let defaults: Vec<DefaultField> = fields
        .named
        .iter()
        .filter_map(|f| DefaultField::from_field(f).transpose())
        .collect::<Result<_>>()?;

    // Collect all user-declared fields BEFORE injecting emitter
    let user_fields: Vec<_> = fields
        .named
        .iter()
        .map(|f| (f.ident.clone().unwrap(), f.ty.clone()))
        .collect();

    // Inject emitter field if this service emits events (AFTER collecting user fields)
    let has_emitter = !emitted_events.is_empty();
    if has_emitter {
        inject_emitter_field(fields);
    }

    // Inject main thread queue field if poll is present
    if let Some(ref poll_types) = poll_signature {
        inject_queue_field(fields, struct_name, poll_types);
    }
    let has_poll = poll_signature.is_some();

    // Always inject cancellation token for graceful shutdown
    inject_cancel_token_field(fields);

    // Always inject join handles for task completion tracking
    inject_join_handles_field(fields);

    // Always inject sampling state for metrics
    inject_sampling_state_field(fields);

    // Generate code
    // NOTE: Handle struct is generated by handlers.rs (it knows command count for metrics)
    let getter_impls = generate_getters(&handle_name, &getters);
    let subscription_methods = generate_subscription_methods(&handle_name, &emitted_events);
    let emit_methods = generate_emit_methods(struct_name, &emitted_events);
    let constructor = generate_constructor(struct_name, &user_fields, &defaults, has_emitter, has_poll);
    let poll_method = generate_poll_method(struct_name, &handle_name, poll_signature.as_ref());
    let shutdown_method = generate_shutdown_method(&handle_name);

    // Remove grove attributes from struct (they've been processed)
    input.attrs.retain(|attr| !attr.path().is_ident("grove"));

    // Remove grove attributes from fields
    if let Data::Struct(data) = &mut input.data {
        if let Fields::Named(fields) = &mut data.fields {
            for field in &mut fields.named {
                field.attrs.retain(|attr| !attr.path().is_ident("grove"));
            }
        }
    }

    Ok(quote! {
        #input
        #getter_impls
        #subscription_methods
        #emit_methods
        #constructor
        #poll_method
        #shutdown_method
    })
}

/// Parsed struct-level grove attributes.
struct StructAttrs {
    emitted_events: Vec<Ident>,
    poll_types: Option<Vec<Type>>,
}

/// Parse all #[grove(...)] attributes from struct.
fn parse_struct_attrs(input: &DeriveInput) -> Result<StructAttrs> {
    let mut emitted_events = Vec::new();
    let mut poll_types: Option<Vec<Type>> = None;

    for attr in &input.attrs {
        if !attr.path().is_ident("grove") {
            continue;
        }

        attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("emits") {
                meta.input.parse::<syn::Token![=]>()?;

                // Parse [Event1, Event2, ...]
                let content;
                syn::bracketed!(content in meta.input);

                while !content.is_empty() {
                    let event: Ident = content.parse()?;
                    emitted_events.push(event);

                    if content.is_empty() {
                        break;
                    }
                    content.parse::<syn::Token![,]>()?;
                }
            } else if meta.path.is_ident("poll") {
                // Parse (&mut T1, &mut T2, ...)
                let content;
                syn::parenthesized!(content in meta.input);

                let parser =
                    syn::punctuated::Punctuated::<Type, syn::Token![,]>::parse_terminated;
                let punctuated = parser.parse2(content.parse()?)?;
                poll_types = Some(punctuated.into_iter().collect());
            }
            Ok(())
        })?;
    }

    Ok(StructAttrs {
        emitted_events,
        poll_types,
    })
}

/// Inject a hidden emitter field into the struct.
fn inject_emitter_field(fields: &mut FieldsNamed) {
    let emitter_field: syn::Field = syn::parse_quote! {
        #[doc(hidden)]
        pub __grove_emitter: grove::event::Emitter
    };
    fields.named.push(emitter_field);
}

/// Inject a hidden cancellation token field into the struct.
fn inject_cancel_token_field(fields: &mut FieldsNamed) {
    let cancel_field: syn::Field = syn::parse_quote! {
        #[doc(hidden)]
        pub __grove_cancel_token: grove::runtime::CancellationToken
    };
    fields.named.push(cancel_field);
}

/// Inject a hidden join handles field into the struct for task completion tracking.
fn inject_join_handles_field(fields: &mut FieldsNamed) {
    let join_handles_field: syn::Field = syn::parse_quote! {
        #[doc(hidden)]
        pub __grove_join_handles: grove::runtime::Arc<grove::runtime::Mutex<Vec<grove::runtime::JoinHandle<()>>>>
    };
    fields.named.push(join_handles_field);
}

/// Inject a hidden sampling state field into the struct for metrics.
fn inject_sampling_state_field(fields: &mut FieldsNamed) {
    let sampling_state_field: syn::Field = syn::parse_quote! {
        #[doc(hidden)]
        pub __grove_sampling_state: grove::metrics::SamplingState
    };
    fields.named.push(sampling_state_field);
}

/// Inject a hidden main thread queue field into the struct.
fn inject_queue_field(fields: &mut FieldsNamed, struct_name: &Ident, poll_types: &[Type]) {
    let queue_field: syn::Field = syn::parse_quote! {
        #[doc(hidden)]
        pub __grove_main_thread_queue: std::sync::Mutex<Vec<Box<dyn FnOnce(&#struct_name, #(#poll_types),*) + Send>>>
    };
    fields.named.push(queue_field);
}

// ============================================================================
// Field Parsing
// ============================================================================

struct GetterField {
    name: Ident,
    ty: Type,
}

impl GetterField {
    fn from_field(field: &Field) -> Result<Option<Self>> {
        let name = field
            .ident
            .clone()
            .expect("we already verified these are named fields");

        // Skip injected grove fields
        if name == "__grove_emitter"
            || name == "__grove_cancel_token"
            || name == "__grove_join_handles"
            || name == "__grove_sampling_state"
        {
            return Ok(None);
        }

        for attr in &field.attrs {
            if !attr.path().is_ident("grove") {
                continue;
            }

            let mut is_getter = false;

            attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("get") {
                    is_getter = true;
                } else if meta.input.peek(syn::Token![=]) {
                    // Skip over unknown metas with = value
                    let _: syn::Expr = meta.value()?.parse()?;
                } else if meta.input.peek(syn::token::Paren) {
                    // Skip over unknown metas with (...)
                    let _content;
                    syn::parenthesized!(_content in meta.input);
                }
                // Otherwise it's just a path like #[grove(something)], which is fine
                Ok(())
            })?;

            if is_getter {
                return Ok(Some(Self {
                    name,
                    ty: field.ty.clone(),
                }));
            }
        }

        Ok(None)
    }
}

struct DefaultField {
    name: Ident,
    #[allow(dead_code)]
    ty: Type,
    default_expr: Option<Expr>,
}

impl DefaultField {
    fn from_field(field: &Field) -> Result<Option<Self>> {
        let name = field
            .ident
            .clone()
            .expect("we already verified these are named fields");

        // Skip injected grove fields
        if name.to_string().starts_with("__grove_") {
            return Ok(None);
        }

        for attr in &field.attrs {
            if !attr.path().is_ident("grove") {
                continue;
            }

            let mut default_expr: Option<Option<Expr>> = None;

            attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("default") {
                    if meta.input.peek(syn::Token![=]) {
                        // Parse default = expr using meta.value()
                        let value = meta.value()?;
                        let expr: Expr = value.parse()?;
                        default_expr = Some(Some(expr));
                    } else {
                        // Just #[grove(default)] - use Default::default()
                        default_expr = Some(None);
                    }
                }
                Ok(())
            })?;

            if let Some(expr) = default_expr {
                return Ok(Some(Self {
                    name,
                    ty: field.ty.clone(),
                    default_expr: expr,
                }));
            }
        }

        Ok(None)
    }
}

// ============================================================================
// Code Generation
// ============================================================================
fn generate_getters(handle_name: &Ident, getters: &[GetterField]) -> TokenStream {
    let getter_methods: Vec<TokenStream> = getters
        .iter()
        .map(|getter| {
            let field_name = &getter.name;
            let field_type = &getter.ty;

            quote! {
                pub fn #field_name(&self) -> #field_type {
                    self.state.read().unwrap().#field_name.clone()
                }
            }
        })
        .collect();

    if getter_methods.is_empty() {
        return quote! {};
    }

    quote! {
        impl #handle_name {
            #(#getter_methods)*
        }
    }
}

fn generate_subscription_methods(handle_name: &Ident, emitted_events: &[Ident]) -> TokenStream {
    if emitted_events.is_empty() {
        return quote! {};
    }

    let subscription_methods: Vec<TokenStream> = emitted_events
        .iter()
        .map(|event| {
            let method_name = format_ident!("on_{}", to_snake_case(&event.to_string()));

            quote! {
                /// Subscribe to this event type.
                pub fn #method_name(&self) -> grove::event::EventReceiver<#event> {
                    grove::event::EventReceiver::new(
                        self.state.read().unwrap().__grove_emitter.subscribe::<#event>()
                    )
                }
            }
        })
        .collect();

    let emit_methods: Vec<TokenStream> = emitted_events
        .iter()
        .map(|event| {
            let method_name = format_ident!("emit_{}", to_snake_case(&event.to_string()));

            quote! {
                /// Emit this event to all subscribers.
                pub fn #method_name(&self, event: #event) {
                    self.state.read().unwrap().__grove_emitter.emit(event);
                }
            }
        })
        .collect();

    // Generate event stats methods
    let stats_methods: Vec<TokenStream> = emitted_events
        .iter()
        .map(|event| {
            let published_method = format_ident!("{}_published", to_snake_case(&event.to_string()));
            let subscribers_method = format_ident!("{}_subscriber_count", to_snake_case(&event.to_string()));

            quote! {
                /// Returns the total number of events published for this event type.
                pub fn #published_method(&self) -> u64 {
                    self.state.read().unwrap().__grove_emitter.published::<#event>()
                }

                /// Returns the current number of subscribers for this event type.
                pub fn #subscribers_method(&self) -> usize {
                    self.state.read().unwrap().__grove_emitter.subscriber_count::<#event>()
                }
            }
        })
        .collect();

    quote! {
        impl #handle_name {
            #(#subscription_methods)*
            #(#emit_methods)*
            #(#stats_methods)*
        }
    }
}

/// Generate the `new()` constructor that initializes all fields.
fn generate_constructor(
    struct_name: &Ident,
    user_fields: &[(Ident, Type)],
    defaults: &[DefaultField],
    has_emitter: bool,
    has_poll: bool,
) -> TokenStream {
    let default_names: std::collections::HashSet<_> = defaults.iter().map(|d| &d.name).collect();

    // Only non-defaulted fields become parameters
    let params: Vec<TokenStream> = user_fields
        .iter()
        .filter(|(name, _)| !default_names.contains(name))
        .map(|(name, ty)| quote! { #name: #ty })
        .collect();

    // All fields need initializers
    let field_inits: Vec<TokenStream> = user_fields
        .iter()
        .map(|(name, _)| {
            if let Some(default) = defaults.iter().find(|d| &d.name == name) {
                match &default.default_expr {
                    Some(expr) => quote! { #name: #expr },
                    None => quote! { #name: Default::default() },
                }
            } else {
                quote! { #name }
            }
        })
        .collect();

    let emitter_init = if has_emitter {
        quote! { __grove_emitter: grove::event::Emitter::new(), }
    } else {
        quote! {}
    };

    let queue_init = if has_poll {
        quote! { __grove_main_thread_queue: std::sync::Mutex::new(Vec::new()), }
    } else {
        quote! {}
    };

    quote! {
        impl #struct_name {
            /// Creates a new instance of this service.
            #[allow(clippy::too_many_arguments)]
            pub fn new(#(#params),*) -> Self {
                Self {
                    #(#field_inits,)*
                    #emitter_init
                    #queue_init
                    __grove_cancel_token: grove::runtime::CancellationToken::new(),
                    __grove_join_handles: grove::runtime::Arc::new(grove::runtime::Mutex::new(Vec::new())),
                    __grove_sampling_state: grove::metrics::SamplingState::new(),
                }
            }

            /// Cancels the service and all its background tasks.
            ///
            /// This cancels the service's cancellation token, which stops the main
            /// event loop and signals background tasks to stop. Tasks should check
            /// for cancellation in their loops using `futures::select!` with
            /// `token.cancelled()`.
            ///
            /// Use the returned `TaskCompletion` to wait for tasks to finish.
            pub fn cancel(&self) -> grove::runtime::TaskCompletion {
                self.__grove_cancel_token.cancel();
                grove::runtime::TaskCompletion::new(self.__grove_join_handles.clone())
            }
        }
    }
}

/// Generate emit_<event>() methods and __wire_emitter helper.
fn generate_emit_methods(struct_name: &Ident, emitted_events: &[Ident]) -> TokenStream {
    if emitted_events.is_empty() {
        // No events - generate a no-op wire_emitter so handlers can always call it
        return quote! {
            impl #struct_name {
                #[doc(hidden)]
                pub fn __wire_emitter(&mut self) {}
            }
        };
    }

    let emit_methods: Vec<TokenStream> = emitted_events
        .iter()
        .map(|event| {
            let method_name = format_ident!("emit_{}", to_snake_case(&event.to_string()));

            quote! {
                /// Emit this event to all subscribers.
                fn #method_name(&self, event: #event) {
                    self.__grove_emitter.emit(event);
                }
            }
        })
        .collect();

    // Generate the wire_emitter helper that spawn() will call
    let channel_creation: Vec<TokenStream> = emitted_events
        .iter()
        .map(|event| {
            quote! {
                builder.add_event::<#event>(256);
            }
        })
        .collect();

    quote! {
        impl #struct_name {
            #(#emit_methods)*

            /// Wires up the event channels. Called automatically by spawn().
            #[doc(hidden)]
            pub fn __wire_emitter(&mut self) {
                let mut builder = grove::event::EmitterBuilder::new();
                #(#channel_creation)*
                self.__grove_emitter = builder.build();
            }
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

/// Generate cancel(), task_completion(), and cancel_token() methods on the handle.
fn generate_shutdown_method(handle_name: &Ident) -> TokenStream {
    quote! {
        impl #handle_name {
            /// Returns the cancellation token for this service.
            ///
            /// Tasks can use this to check for cancellation or wait on `token.cancelled()`.
            pub fn cancel_token(&self) -> grove::runtime::CancellationToken {
                self.state.read().unwrap().__grove_cancel_token.clone()
            }

            /// Cancels the service and all its background tasks.
            ///
            /// This cancels the service's cancellation token, which stops the main
            /// event loop and signals background tasks to stop. Tasks should check
            /// for cancellation in their loops using `futures::select!` with
            /// `token.cancelled()`.
            ///
            /// Use the returned `TaskCompletion` to wait for tasks to finish.
            pub fn cancel(&self) -> grove::runtime::TaskCompletion {
                self.state.read().unwrap().__grove_cancel_token.cancel();
                self.task_completion()
            }

            /// Returns a handle for waiting on task completion.
            ///
            /// This can be used to monitor task status without cancelling.
            pub fn task_completion(&self) -> grove::runtime::TaskCompletion {
                grove::runtime::TaskCompletion::new(self.state.read().unwrap().__grove_join_handles.clone())
            }
        }
    }
}

/// Generate the poll() method on the handle.
fn generate_poll_method(
    _struct_name: &Ident,
    handle_name: &Ident,
    poll_types: Option<&Vec<Type>>,
) -> TokenStream {
    let poll_types = match poll_types {
        Some(t) => t,
        None => return quote! {},
    };

    // Generate parameter names and declarations
    let poll_params: Vec<_> = poll_types
        .iter()
        .enumerate()
        .map(|(i, ty)| {
            let name = format_ident!("__poll_arg_{}", i);
            (name, ty)
        })
        .collect();

    let param_decls: Vec<TokenStream> = poll_params
        .iter()
        .map(|(name, ty)| quote! { #name: #ty })
        .collect();

    let param_names: Vec<&Ident> = poll_params.iter().map(|(name, _)| name).collect();

    quote! {
        impl #handle_name {
            /// Returns true if there is queued work waiting to be executed.
            pub fn has_queued_work(&self) -> bool {
                !self.state.read().unwrap()
                    .__grove_main_thread_queue
                    .lock()
                    .unwrap()
                    .is_empty()
            }

            /// Executes all queued main-thread work.
            ///
            /// Call this from the main thread to run work that was queued
            /// by `#[grove(command, poll)]` handlers.
            ///
            /// Returns `true` if any work was executed.
            pub fn poll(&self, #(#param_decls),*) -> bool {
                // Drain the queue while holding the lock briefly
                let queue: Vec<_> = {
                    self.state.write().unwrap()
                        .__grove_main_thread_queue
                        .lock()
                        .unwrap()
                        .drain(..)
                        .collect()
                };
                let had_work = !queue.is_empty();
                // Execute each work item with read access to state
                for work in queue {
                    work(&*self.state.read().unwrap(), #(#param_names),*);
                }
                had_work
            }
        }
    }
}
